Write a function that adds an element to the hash table.

Prototype: int hash_table_set(hash_table_t *ht, const char *key, const char *value);
Where ht is the hash table you want to add or update the key/value to
key is the key. key can not be an empty string
and value is the value associated with the key. value must be duplicated. value can be an empty string
Returns: 1 if it succeeded, 0 otherwise
In case of collision, add the new node at the beginning of the list

If you want to test for collisions, here are some strings that collide using the djb2 algorithm:

hetairas collides with mentioner
heliotropes collides with neurospora
depravement collides with serafins
stylist collides with subgenera
joyful collides with synaphea
redescribed collides with urites
dram collides with vivency

Solution with explanation (paste here due to Betty coding style's restriction of 40 lines in the function file):

int hash_table_set(hash_table_t *ht, const char *key, const char *value)
{
        unsigned long int index;
        hash_node_t *new_node;
        hash_node_t *current;
        char *duplicate_value;

        /* Validate input: hash table and key must not be NULL or empty */
        if (ht == NULL || key == NULL || *key == '\0' || value == NULL)
                return (0);
        /* Get the index in the array using the key */
        index = key_index((const unsigned char *)key, ht->size);
        /* Traverse the linked list at this index to see if the key already exists */
        current = ht->array[index];
        while (current != NULL)
        {
                if (strcmp(current->key, key) == 0)
                {
                        /* If key exists, update the value of the key (only after freeing the old value) */
                        free(current->value);
                        duplicate_value = strdup(value);
                        if (duplicate_value == NULL)
                                return (0);
                        /* Replace the old value with the new duplicated string to the current node in the hash table (key already exists) */
                        current->value = duplicate_value;
                        return (1);
                }
                /* Move to the next node in the linked list(chain) to keep searching */
                current = current->next;
        }
        /* Key does not exist: create a new node and allocate memory */
        new_node = malloc(sizeof(hash_node_t));
        /* If malloc fails */
        if (new_node == NULL)
                return (0);
        /* Duplicate key and value strings */
        new_node->key = strdup(key);
        new_node->value = strdup(value);
        /* Validate the duplicate key and its value, must not be NULL */
        if (new_node->key == NULL || new_node->value == NULL)
        {
                /* Clean up on failure */
                free(new_node->key);
                free(new_node->value);
                free(new_node);
                return (0);
        }
        /* Insert the new node at the start of the list (handling collision) */
        new_node->next = ht->array[index];
        ht->array[index] = new_node;
        return (1);
}
